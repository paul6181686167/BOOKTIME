#!/usr/bin/env python3
"""
Test sp√©cifique pour la validation du probl√®me de synchronisation 
Ajout/Affichage Livres avec Open Library Import
"""
import requests
import json
import uuid
from datetime import datetime

# Configuration
BACKEND_URL = "https://8b9f9a3a-f7e8-42a0-96f8-6b1947012e49.preview.emergentagent.com"
API_URL = f"{BACKEND_URL}/api"

class OpenLibraryImportTest:
    def __init__(self):
        self.test_user = None
        self.auth_token = None
        self.created_books = []
        
    def setup_test_user(self):
        """Cr√©er un utilisateur de test et obtenir le token d'authentification"""
        print("üîß Configuration de l'utilisateur de test...")
        
        # Cr√©er un utilisateur unique
        user_data = {
            "first_name": f"TestOL{datetime.now().strftime('%H%M%S')}",
            "last_name": "ImportUser"
        }
        
        response = requests.post(f"{API_URL}/auth/register", json=user_data)
        if response.status_code == 200:
            result = response.json()
            self.test_user = result["user"]
            self.auth_token = result["access_token"]
            print(f"‚úÖ Utilisateur cr√©√©: {self.test_user['first_name']} {self.test_user['last_name']}")
            return True
        else:
            print(f"‚ùå Erreur cr√©ation utilisateur: {response.status_code} - {response.text}")
            return False
    
    def get_auth_headers(self):
        """Retourner les headers d'authentification"""
        return {"Authorization": f"Bearer {self.auth_token}"}
    
    def test_openlibrary_search(self):
        """Test 1: V√©rifier que l'API Open Library Search fonctionne"""
        print("\nüìö Test 1: API Open Library Search")
        
        search_terms = ["Harry Potter", "Le Petit Prince", "One Piece"]
        
        for term in search_terms:
            response = requests.get(
                f"{API_URL}/openlibrary/search",
                params={"q": term, "limit": 5},
                headers=self.get_auth_headers()
            )
            
            if response.status_code == 200:
                data = response.json()
                print(f"‚úÖ Recherche '{term}': {len(data.get('books', []))} livres trouv√©s")
                
                # V√©rifier la structure des donn√©es
                if data.get('books'):
                    book = data['books'][0]
                    required_fields = ['ol_key', 'title', 'author', 'category']
                    missing_fields = [field for field in required_fields if field not in book]
                    if missing_fields:
                        print(f"‚ö†Ô∏è  Champs manquants dans les r√©sultats: {missing_fields}")
                    else:
                        print(f"‚úÖ Structure des donn√©es correcte pour '{term}'")
            else:
                print(f"‚ùå Erreur recherche '{term}': {response.status_code} - {response.text}")
                return False
        
        return True
    
    def test_openlibrary_import(self):
        """Test 2: V√©rifier que l'import depuis Open Library fonctionne"""
        print("\nüì• Test 2: API Open Library Import")
        
        # D'abord, chercher un livre pour obtenir un ol_key valide
        search_response = requests.get(
            f"{API_URL}/openlibrary/search",
            params={"q": "Harry Potter", "limit": 1},
            headers=self.get_auth_headers()
        )
        
        if search_response.status_code != 200:
            print(f"‚ùå Impossible de chercher un livre pour l'import: {search_response.status_code}")
            return False
        
        search_data = search_response.json()
        if not search_data.get('books'):
            print("‚ùå Aucun livre trouv√© pour l'import")
            return False
        
        book_to_import = search_data['books'][0]
        ol_key = book_to_import['ol_key']
        
        print(f"üìñ Import du livre: {book_to_import['title']} (ol_key: {ol_key})")
        
        # Tester l'import
        import_data = {
            "ol_key": ol_key,
            "category": "roman"
        }
        
        response = requests.post(
            f"{API_URL}/openlibrary/import",
            json=import_data,
            headers=self.get_auth_headers()
        )
        
        if response.status_code == 200:
            imported_book = response.json()
            print(f"üìã R√©ponse import: {json.dumps(imported_book, indent=2)}")
            
            # La r√©ponse contient un champ 'book' avec les donn√©es du livre
            if 'book' in imported_book:
                book_data = imported_book['book']
                self.created_books.append(book_data['id'])  # Utiliser 'id' au lieu de '_id'
                print(f"‚úÖ Livre import√© avec succ√®s: {book_data['title']}")
                print(f"   ID: {book_data['id']}")
                print(f"   Auteur: {book_data['author']}")
                print(f"   Cat√©gorie: {book_data['category']}")
                return book_data
            else:
                print(f"‚ö†Ô∏è  Structure de r√©ponse inattendue: {list(imported_book.keys())}")
                return imported_book
        else:
            print(f"‚ùå Erreur import: {response.status_code} - {response.text}")
            return False
    
    def test_books_api_after_import(self, imported_book):
        """Test 3: V√©rifier que le livre import√© appara√Æt dans l'API Books"""
        print("\nüìã Test 3: V√©rification API Books apr√®s import")
        
        # Test 3a: GET /api/books - R√©cup√©rer tous les livres
        response = requests.get(f"{API_URL}/books", headers=self.get_auth_headers())
        
        if response.status_code == 200:
            books_data = response.json()
            
            # L'API retourne une structure pagin√©e avec 'items'
            if isinstance(books_data, dict) and 'items' in books_data:
                books = books_data['items']
                total = books_data['total']
                print(f"‚úÖ API Books fonctionne: {len(books)} livres sur {total} total")
            else:
                # Fallback si c'est une liste directe
                books = books_data if isinstance(books_data, list) else []
                print(f"‚úÖ API Books fonctionne: {len(books)} livres trouv√©s")
            
            # Chercher le livre import√©
            book_id = imported_book['id']
            imported_book_found = None
            for book in books:
                # Les livres peuvent avoir '_id' et/ou 'id'
                if book.get('_id') == book_id or book.get('id') == book_id:
                    imported_book_found = book
                    break
            
            if imported_book_found:
                print(f"‚úÖ Livre import√© trouv√© dans la liste: {imported_book_found['title']}")
                
                # V√©rifier les champs requis
                required_fields = ['title', 'author', 'category', 'status']
                missing_fields = [field for field in required_fields if field not in imported_book_found]
                if missing_fields:
                    print(f"‚ö†Ô∏è  Champs manquants: {missing_fields}")
                else:
                    print("‚úÖ Tous les champs requis sont pr√©sents")
            else:
                print(f"‚ùå Livre import√© NON trouv√© dans la liste des livres!")
                print(f"   ID recherch√©: {book_id}")
                if books:
                    print(f"   IDs disponibles: {[book.get('_id', book.get('id', 'NO_ID')) for book in books[:5]]}")
                return False
        else:
            print(f"‚ùå Erreur API Books: {response.status_code} - {response.text}")
            return False
        
        # Test 3b: GET /api/books/{book_id} - R√©cup√©rer le livre sp√©cifique
        response = requests.get(
            f"{API_URL}/books/{imported_book['id']}", 
            headers=self.get_auth_headers()
        )
        
        if response.status_code == 200:
            specific_book = response.json()
            print(f"‚úÖ Livre sp√©cifique r√©cup√©r√©: {specific_book['title']}")
        else:
            print(f"‚ùå Erreur r√©cup√©ration livre sp√©cifique: {response.status_code}")
            return False
        
        # Test 3c: Filtrage par cat√©gorie
        category = imported_book['category']
        response = requests.get(
            f"{API_URL}/books",
            params={"category": category},
            headers=self.get_auth_headers()
        )
        
        if response.status_code == 200:
            filtered_data = response.json()
            
            # G√©rer la structure pagin√©e
            if isinstance(filtered_data, dict) and 'items' in filtered_data:
                filtered_books = filtered_data['items']
            else:
                filtered_books = filtered_data if isinstance(filtered_data, list) else []
            
            book_found_in_filter = any(
                book.get('_id') == imported_book['id'] or book.get('id') == imported_book['id'] 
                for book in filtered_books
            )
            if book_found_in_filter:
                print(f"‚úÖ Livre trouv√© dans le filtre cat√©gorie '{category}'")
            else:
                print(f"‚ùå Livre NON trouv√© dans le filtre cat√©gorie '{category}'")
                return False
        else:
            print(f"‚ùå Erreur filtrage par cat√©gorie: {response.status_code}")
            return False
        
        return True
    
    def test_stats_update(self):
        """Test 4: V√©rifier que les statistiques sont mises √† jour"""
        print("\nüìä Test 4: V√©rification mise √† jour des statistiques")
        
        response = requests.get(f"{API_URL}/stats", headers=self.get_auth_headers())
        
        if response.status_code == 200:
            stats = response.json()
            print(f"‚úÖ Statistiques r√©cup√©r√©es:")
            print(f"   Total livres: {stats['total_books']}")
            print(f"   Romans: {stats['categories'].get('roman', 0)}")
            print(f"   BD: {stats['categories'].get('bd', 0)}")
            print(f"   Mangas: {stats['categories'].get('manga', 0)}")
            
            # V√©rifier que nous avons au moins 1 livre (celui qu'on vient d'importer)
            if stats['total_books'] >= 1:
                print("‚úÖ Les statistiques refl√®tent l'ajout du livre")
                return True
            else:
                print("‚ùå Les statistiques ne refl√®tent pas l'ajout du livre")
                return False
        else:
            print(f"‚ùå Erreur r√©cup√©ration statistiques: {response.status_code}")
            return False
    
    def test_authentication_required(self):
        """Test 5: V√©rifier que l'authentification est requise"""
        print("\nüîê Test 5: V√©rification authentification requise")
        
        endpoints_to_test = [
            f"{API_URL}/books",
            f"{API_URL}/openlibrary/search?q=test",
            f"{API_URL}/stats"
        ]
        
        for endpoint in endpoints_to_test:
            # Test sans token
            response = requests.get(endpoint)
            if response.status_code == 401:
                print(f"‚úÖ {endpoint.split('/')[-1]}: Authentification requise (401)")
            else:
                print(f"‚ö†Ô∏è  {endpoint.split('/')[-1]}: Pas d'authentification requise ({response.status_code})")
        
        return True
    
    def test_duplicate_import_prevention(self):
        """Test 6: V√©rifier la pr√©vention des doublons"""
        print("\nüîÑ Test 6: Pr√©vention des doublons")
        
        if not self.created_books:
            print("‚ö†Ô∏è  Aucun livre cr√©√© pour tester les doublons")
            return True
        
        # Essayer d'importer le m√™me livre √† nouveau
        search_response = requests.get(
            f"{API_URL}/openlibrary/search",
            params={"q": "Harry Potter", "limit": 1},
            headers=self.get_auth_headers()
        )
        
        if search_response.status_code == 200:
            search_data = search_response.json()
            if search_data.get('books'):
                ol_key = search_data['books'][0]['ol_key']
                
                import_data = {
                    "ol_key": ol_key,
                    "category": "roman"
                }
                
                response = requests.post(
                    f"{API_URL}/openlibrary/import",
                    json=import_data,
                    headers=self.get_auth_headers()
                )
                
                if response.status_code == 409:  # Conflict - duplicate
                    print("‚úÖ Pr√©vention des doublons fonctionne (409 Conflict)")
                elif response.status_code == 200:
                    print("‚ö†Ô∏è  Doublon autoris√© - peut √™tre normal selon l'impl√©mentation")
                else:
                    print(f"‚ö†Ô∏è  R√©ponse inattendue pour doublon: {response.status_code}")
        
        return True
    
    def cleanup(self):
        """Nettoyer les donn√©es de test"""
        print("\nüßπ Nettoyage des donn√©es de test...")
        
        for book_id in self.created_books:
            try:
                response = requests.delete(
                    f"{API_URL}/books/{book_id}",
                    headers=self.get_auth_headers()
                )
                if response.status_code == 200:
                    print(f"‚úÖ Livre supprim√©: {book_id}")
                else:
                    print(f"‚ö†Ô∏è  Erreur suppression livre {book_id}: {response.status_code}")
            except Exception as e:
                print(f"‚ö†Ô∏è  Exception lors de la suppression: {e}")
    
    def run_all_tests(self):
        """Ex√©cuter tous les tests"""
        print("üöÄ D√©but des tests Open Library Import")
        print("=" * 60)
        
        # Configuration
        if not self.setup_test_user():
            print("‚ùå Impossible de configurer l'utilisateur de test")
            return False
        
        try:
            # Tests principaux
            tests_results = []
            
            # Test 1: Open Library Search
            tests_results.append(("Open Library Search", self.test_openlibrary_search()))
            
            # Test 2: Open Library Import
            imported_book = self.test_openlibrary_import()
            tests_results.append(("Open Library Import", bool(imported_book)))
            
            if imported_book:
                # Test 3: Books API apr√®s import
                tests_results.append(("Books API apr√®s import", self.test_books_api_after_import(imported_book)))
                
                # Test 4: Mise √† jour des statistiques
                tests_results.append(("Mise √† jour statistiques", self.test_stats_update()))
            
            # Test 5: Authentification
            tests_results.append(("Authentification requise", self.test_authentication_required()))
            
            # Test 6: Pr√©vention doublons
            tests_results.append(("Pr√©vention doublons", self.test_duplicate_import_prevention()))
            
            # R√©sum√©
            print("\n" + "=" * 60)
            print("üìã R√âSUM√â DES TESTS")
            print("=" * 60)
            
            all_passed = True
            for test_name, result in tests_results:
                status = "‚úÖ PASS" if result else "‚ùå FAIL"
                print(f"{status} {test_name}")
                if not result:
                    all_passed = False
            
            print("\n" + "=" * 60)
            if all_passed:
                print("üéâ TOUS LES TESTS SONT PASS√âS!")
                print("‚úÖ Le backend fonctionne parfaitement pour l'import Open Library")
                print("‚úÖ Le probl√®me √©tait bien uniquement c√¥t√© frontend (UX)")
            else:
                print("‚ö†Ô∏è  CERTAINS TESTS ONT √âCHOU√â")
                print("üîç V√©rifier les d√©tails ci-dessus pour identifier les probl√®mes")
            
            return all_passed
            
        finally:
            # Nettoyage
            self.cleanup()

if __name__ == "__main__":
    test_runner = OpenLibraryImportTest()
    success = test_runner.run_all_tests()
    exit(0 if success else 1)