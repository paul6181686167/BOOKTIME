#!/usr/bin/env python3
"""
üéØ ORCHESTRATEUR AUTOMATISATION S√âRIES OPEN LIBRARY
Pipeline compl√®te d'automatisation pour BOOKTIME

Fonctionnalit√©s :
- Ex√©cution automatique r√©cup√©ration s√©ries Open Library
- Mise √† jour syst√®me de d√©tection
- Red√©marrage services si n√©cessaire
- Validation end-to-end
- Rapport consolid√©

Utilisation :
python series_automation_pipeline.py
python series_automation_pipeline.py --quick --limit=20
python series_automation_pipeline.py --full --limit=100
python series_automation_pipeline.py --test-only
"""

import asyncio
import subprocess
import sys
import json
import logging
from pathlib import Path
from datetime import datetime
from typing import Dict, List
import argparse

# Configuration logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class SeriesAutomationPipeline:
    """Pipeline compl√®te d'automatisation s√©ries"""
    
    def __init__(self):
        self.scripts_dir = Path('/app/backend/scripts')
        self.logs_dir = Path('/app/logs')
        self.reports_dir = Path('/app/reports')
        
        # Cr√©ation dossiers
        self.logs_dir.mkdir(exist_ok=True)
        self.reports_dir.mkdir(exist_ok=True)
        
        self.pipeline_stats = {
            'start_time': datetime.now(),
            'steps_completed': 0,
            'total_steps': 5,
            'errors': [],
            'series_added': 0,
            'series_updated': 0
        }
    
    def log_step(self, step_name: str, success: bool, details: str = ""):
        """Logging √©tape pipeline"""
        self.pipeline_stats['steps_completed'] += 1
        status = "‚úÖ" if success else "‚ùå"
        
        logger.info(f"{status} [{self.pipeline_stats['steps_completed']}/{self.pipeline_stats['total_steps']}] {step_name}")
        
        if details:
            logger.info(f"   {details}")
        
        if not success:
            self.pipeline_stats['errors'].append(f"{step_name}: {details}")
    
    async def step_1_fetch_series(self, mode: str = 'popular', limit: int = 50) -> Dict:
        """√âtape 1: R√©cup√©ration s√©ries Open Library"""
        logger.info("üîç √âTAPE 1: R√©cup√©ration s√©ries Open Library")
        
        try:
            # Ex√©cution script r√©cup√©ration
            cmd = [
                sys.executable,
                str(self.scripts_dir / 'open_library_series_auto.py'),
                '--mode', mode,
                '--limit', str(limit)
            ]
            
            logger.info(f"Commande: {' '.join(cmd)}")
            
            # Ex√©cution avec capture sortie
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                # Parsing r√©sultat depuis stdout
                output = stdout.decode('utf-8')
                
                # Extraction m√©triques (parsing basique)
                series_added = 0
                duplicates_skipped = 0
                
                lines = output.split('\n')
                for line in lines:
                    if 'S√©ries ajout√©es:' in line:
                        try:
                            series_added = int(line.split(':')[1].strip())
                        except:
                            pass
                    elif 'Doublons ignor√©s:' in line:
                        try:
                            duplicates_skipped = int(line.split(':')[1].strip())
                        except:
                            pass
                
                self.pipeline_stats['series_added'] = series_added
                self.log_step("R√©cup√©ration s√©ries Open Library", True, 
                             f"{series_added} s√©ries ajout√©es, {duplicates_skipped} doublons ignor√©s")
                
                return {
                    'success': True,
                    'series_added': series_added,
                    'duplicates_skipped': duplicates_skipped,
                    'output': output
                }
            
            else:
                error_msg = stderr.decode('utf-8')
                self.log_step("R√©cup√©ration s√©ries Open Library", False, 
                             f"Code erreur: {process.returncode}, {error_msg}")
                
                return {
                    'success': False,
                    'error': error_msg,
                    'return_code': process.returncode
                }
        
        except Exception as e:
            self.log_step("R√©cup√©ration s√©ries Open Library", False, str(e))
            return {'success': False, 'error': str(e)}
    
    def step_2_update_detection(self) -> Dict:
        """√âtape 2: Mise √† jour syst√®me d√©tection"""
        logger.info("üîÑ √âTAPE 2: Mise √† jour syst√®me d√©tection")
        
        try:
            # Ex√©cution script mise √† jour
            cmd = [
                sys.executable,
                str(self.scripts_dir / 'update_series_detection.py')
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300  # 5 minutes timeout
            )
            
            if result.returncode == 0:
                # Parsing r√©sultat
                series_count = 0
                lines = result.stdout.split('\n')
                for line in lines:
                    if 'S√©ries trait√©es:' in line:
                        try:
                            series_count = int(line.split(':')[1].strip())
                        except:
                            pass
                
                self.pipeline_stats['series_updated'] = series_count
                self.log_step("Mise √† jour syst√®me d√©tection", True,
                             f"{series_count} s√©ries dans le syst√®me")
                
                return {
                    'success': True,
                    'series_count': series_count,
                    'output': result.stdout
                }
            
            else:
                self.log_step("Mise √† jour syst√®me d√©tection", False,
                             f"Code erreur: {result.returncode}, {result.stderr}")
                
                return {
                    'success': False,
                    'error': result.stderr,
                    'return_code': result.returncode
                }
        
        except Exception as e:
            self.log_step("Mise √† jour syst√®me d√©tection", False, str(e))
            return {'success': False, 'error': str(e)}
    
    def step_3_restart_services(self) -> Dict:
        """√âtape 3: Red√©marrage services"""
        logger.info("üîÑ √âTAPE 3: Red√©marrage services")
        
        try:
            # Red√©marrage frontend pour prise en compte nouvelles s√©ries
            cmd = ['sudo', 'supervisorctl', 'restart', 'frontend']
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                self.log_step("Red√©marrage services", True,
                             "Frontend red√©marr√© avec succ√®s")
                return {'success': True, 'output': result.stdout}
            
            else:
                self.log_step("Red√©marrage services", False,
                             f"Erreur red√©marrage: {result.stderr}")
                return {'success': False, 'error': result.stderr}
        
        except Exception as e:
            self.log_step("Red√©marrage services", False, str(e))
            return {'success': False, 'error': str(e)}
    
    def step_4_validate_integration(self) -> Dict:
        """√âtape 4: Validation int√©gration"""
        logger.info("üß™ √âTAPE 4: Validation int√©gration")
        
        try:
            # V√©rification fichiers g√©n√©r√©s
            js_file = Path('/app/frontend/src/data/extendedSeriesDatabase.js')
            json_file = Path('/app/backend/data/extended_series_database.json')
            
            if not js_file.exists():
                self.log_step("Validation int√©gration", False,
                             "Fichier JS manquant")
                return {'success': False, 'error': 'Fichier JS manquant'}
            
            if not json_file.exists():
                self.log_step("Validation int√©gration", False,
                             "Fichier JSON manquant")
                return {'success': False, 'error': 'Fichier JSON manquant'}
            
            # V√©rification contenu JS
            with open(js_file, 'r', encoding='utf-8') as f:
                js_content = f.read()
            
            if 'EXTENDED_SERIES_DATABASE' not in js_content:
                self.log_step("Validation int√©gration", False,
                             "Contenu JS invalide")
                return {'success': False, 'error': 'Contenu JS invalide'}
            
            # V√©rification contenu JSON
            with open(json_file, 'r', encoding='utf-8') as f:
                json_data = json.load(f)
            
            if not isinstance(json_data, list) or len(json_data) == 0:
                self.log_step("Validation int√©gration", False,
                             "Donn√©es JSON invalides")
                return {'success': False, 'error': 'Donn√©es JSON invalides'}
            
            # Validation structure
            required_fields = ['name', 'authors', 'category', 'volumes']
            for series in json_data[:5]:  # V√©rification √©chantillon
                for field in required_fields:
                    if field not in series:
                        self.log_step("Validation int√©gration", False,
                                     f"Champ manquant: {field}")
                        return {'success': False, 'error': f'Champ manquant: {field}'}
            
            self.log_step("Validation int√©gration", True,
                         f"Fichiers valid√©s: {len(json_data)} s√©ries")
            
            return {
                'success': True,
                'series_count': len(json_data),
                'js_file_size': js_file.stat().st_size,
                'json_file_size': json_file.stat().st_size
            }
        
        except Exception as e:
            self.log_step("Validation int√©gration", False, str(e))
            return {'success': False, 'error': str(e)}
    
    def step_5_generate_report(self, step_results: List[Dict]) -> Dict:
        """√âtape 5: G√©n√©ration rapport final"""
        logger.info("üìä √âTAPE 5: G√©n√©ration rapport final")
        
        try:
            # Compilation statistiques
            total_series = self.pipeline_stats['series_added']
            total_updated = self.pipeline_stats['series_updated']
            duration = datetime.now() - self.pipeline_stats['start_time']
            
            # G√©n√©ration rapport
            report = f"""
üéØ RAPPORT PIPELINE AUTOMATISATION S√âRIES OPEN LIBRARY
======================================================

üìä R√âSUM√â EX√âCUTION
- Date: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
- Dur√©e totale: {duration}
- √âtapes compl√©t√©es: {self.pipeline_stats['steps_completed']}/{self.pipeline_stats['total_steps']}
- Statut: {'‚úÖ SUCC√àS' if len(self.pipeline_stats['errors']) == 0 else '‚ùå ERREURS'}

üî¢ STATISTIQUES S√âRIES
- Nouvelles s√©ries ajout√©es: {total_series}
- S√©ries totales dans syst√®me: {total_updated}
- Doublons ignor√©s: {step_results[0].get('duplicates_skipped', 0) if step_results else 0}

üìã D√âTAIL √âTAPES
"""
            
            # D√©tail des √©tapes
            step_names = [
                "R√©cup√©ration s√©ries Open Library",
                "Mise √† jour syst√®me d√©tection",
                "Red√©marrage services",
                "Validation int√©gration",
                "G√©n√©ration rapport final"
            ]
            
            for i, (step_name, step_result) in enumerate(zip(step_names, step_results)):
                status = "‚úÖ" if step_result.get('success', False) else "‚ùå"
                report += f"{i+1}. {status} {step_name}\n"
                
                if not step_result.get('success', False):
                    report += f"   Erreur: {step_result.get('error', 'Inconnue')}\n"
            
            # Erreurs
            if self.pipeline_stats['errors']:
                report += f"\n‚ùå ERREURS RENCONTR√âES ({len(self.pipeline_stats['errors'])})\n"
                for error in self.pipeline_stats['errors']:
                    report += f"- {error}\n"
            
            # Prochaines √©tapes
            report += f"""
üöÄ PROCHAINES √âTAPES
- Tester fonctionnalit√©s masquage intelligent
- V√©rifier d√©tection automatique s√©ries
- Surveiller logs d√©tection
- Planifier prochaine ex√©cution automatisation

üìÅ FICHIERS G√âN√âR√âS
- Donn√©es JSON: /app/backend/data/extended_series_database.json
- Syst√®me JS: /app/frontend/src/data/extendedSeriesDatabase.js
- Logs: /app/logs/
- Rapports: /app/reports/

‚ö° PERFORMANCE
- S√©ries par minute: {total_series / max(1, duration.total_seconds() / 60):.1f}
- Efficacit√©: {(total_series / max(1, total_series + step_results[0].get('duplicates_skipped', 0))) * 100:.1f}% (nouvelles/total)
"""
            
            # Sauvegarde rapport
            report_file = self.reports_dir / f"pipeline_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            
            with open(report_file, 'w', encoding='utf-8') as f:
                f.write(report)
            
            self.log_step("G√©n√©ration rapport final", True,
                         f"Rapport sauvegard√©: {report_file}")
            
            return {
                'success': True,
                'report_file': str(report_file),
                'report_content': report
            }
        
        except Exception as e:
            self.log_step("G√©n√©ration rapport final", False, str(e))
            return {'success': False, 'error': str(e)}
    
    async def run_pipeline(self, mode: str = 'popular', limit: int = 50, test_only: bool = False) -> Dict:
        """Ex√©cution pipeline compl√®te"""
        
        logger.info("üöÄ D√âMARRAGE PIPELINE AUTOMATISATION S√âRIES")
        logger.info(f"Mode: {mode}, Limit: {limit}, Test: {test_only}")
        
        step_results = []
        
        # √âtape 1: R√©cup√©ration s√©ries
        if not test_only:
            result_1 = await self.step_1_fetch_series(mode, limit)
            step_results.append(result_1)
            
            if not result_1['success']:
                logger.error("‚ùå √âchec √©tape 1 - Arr√™t pipeline")
                return {'success': False, 'error': '√âchec r√©cup√©ration s√©ries'}
        
        else:
            # Mode test - simulation
            self.log_step("R√©cup√©ration s√©ries Open Library (TEST)", True, "Mode test activ√©")
            step_results.append({'success': True, 'test_mode': True})
        
        # √âtape 2: Mise √† jour d√©tection
        result_2 = self.step_2_update_detection()
        step_results.append(result_2)
        
        if not result_2['success']:
            logger.error("‚ùå √âchec √©tape 2 - Arr√™t pipeline")
            return {'success': False, 'error': '√âchec mise √† jour d√©tection'}
        
        # √âtape 3: Red√©marrage services
        result_3 = self.step_3_restart_services()
        step_results.append(result_3)
        
        if not result_3['success']:
            logger.warning("‚ö†Ô∏è √âchec √©tape 3 - Continuation pipeline")
        
        # √âtape 4: Validation
        result_4 = self.step_4_validate_integration()
        step_results.append(result_4)
        
        if not result_4['success']:
            logger.error("‚ùå √âchec √©tape 4 - Arr√™t pipeline")
            return {'success': False, 'error': '√âchec validation'}
        
        # √âtape 5: Rapport
        result_5 = self.step_5_generate_report(step_results)
        step_results.append(result_5)
        
        # R√©sultat final
        success = all(r['success'] for r in step_results)
        
        if success:
            logger.info("üéâ PIPELINE TERMIN√â AVEC SUCC√àS")
        else:
            logger.error("‚ùå PIPELINE TERMIN√â AVEC ERREURS")
        
        return {
            'success': success,
            'step_results': step_results,
            'total_duration': datetime.now() - self.pipeline_stats['start_time'],
            'series_added': self.pipeline_stats['series_added'],
            'series_updated': self.pipeline_stats['series_updated'],
            'errors': self.pipeline_stats['errors']
        }


async def main():
    """Fonction principale CLI"""
    parser = argparse.ArgumentParser(description='Pipeline automatisation s√©ries')
    parser.add_argument('--mode',
                       choices=['popular', 'authors', 'categories'],
                       default='popular',
                       help='Mode de r√©cup√©ration')
    parser.add_argument('--limit',
                       type=int,
                       default=50,
                       help='Nombre maximum de s√©ries')
    parser.add_argument('--quick',
                       action='store_true',
                       help='Ex√©cution rapide (limit=20)')
    parser.add_argument('--full',
                       action='store_true',
                       help='Ex√©cution compl√®te (limit=100)')
    parser.add_argument('--test-only',
                       action='store_true',
                       help='Mode test sans r√©cup√©ration')
    
    args = parser.parse_args()
    
    # Ajustement limite selon mode
    if args.quick:
        args.limit = 20
    elif args.full:
        args.limit = 100
    
    # Cr√©ation pipeline
    pipeline = SeriesAutomationPipeline()
    
    # Ex√©cution
    result = await pipeline.run_pipeline(
        mode=args.mode,
        limit=args.limit,
        test_only=args.test_only
    )
    
    # Affichage r√©sultat
    if result['success']:
        print(f"\nüéâ PIPELINE R√âUSSI")
        print(f"üìä S√©ries ajout√©es: {result['series_added']}")
        print(f"üîÑ S√©ries dans syst√®me: {result['series_updated']}")
        print(f"‚è±Ô∏è Dur√©e: {result['total_duration']}")
        
        if result['step_results'] and result['step_results'][-1]['success']:
            print(f"üìã Rapport: {result['step_results'][-1]['report_file']}")
    
    else:
        print(f"\n‚ùå PIPELINE √âCHOU√â")
        print(f"üö® Erreurs: {len(result['errors'])}")
        for error in result['errors']:
            print(f"   - {error}")
        
        return 1
    
    return 0


if __name__ == "__main__":
    exit(asyncio.run(main()))