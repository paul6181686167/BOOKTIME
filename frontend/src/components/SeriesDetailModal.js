import React, { useState, useEffect } from 'react';
import {
  BookOpenIcon,
  CheckCircleIcon,
  ClockIcon,
  PlusIcon,
  MagnifyingGlassIcon,
  ExclamationTriangleIcon,
  SparklesIcon
} from '@heroicons/react/24/outline';
import { bookService } from '../services/bookService';
import { EXTENDED_SERIES_DATABASE } from '../utils/seriesDatabaseExtended';
import TomeDropdown from './TomeDropdown'; // ‚Üê AJOUT : Import du nouveau composant
import toast from 'react-hot-toast';

const SeriesDetailModal = ({ 
  series, 
  isOpen, 
  onClose, 
  onUpdate,
  onAddSeries
}) => {
  const [books, setBooks] = useState([]);
  const [loading, setLoading] = useState(false);
  const [selectedTomes, setSelectedTomes] = useState(new Set());
  const [autoCompleting, setAutoCompleting] = useState(false);
  const [analyzing, setAnalyzing] = useState(false);
  const [missingAnalysis, setMissingAnalysis] = useState(null);
  const [isSeriesOwned, setIsSeriesOwned] = useState(false);
  const [seriesStatus, setSeriesStatus] = useState('to_read');
  const [readTomes, setReadTomes] = useState(new Set()); // ‚Üê AJOUT: √âtat des tomes lus/non lus
  const [missingPreviousWarning, setMissingPreviousWarning] = useState(null); // ‚Üê AJOUT: Avertissement tomes pr√©c√©dents manquants

  // ‚úÖ NOUVELLE FONCTION : Charger les pr√©f√©rences de lecture depuis la base de donn√©es
  const loadReadingPreferences = async (seriesName) => {
    try {
      const token = localStorage.getItem('token');
      const backendUrl = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8001';
      
      const response = await fetch(`${backendUrl}/api/series/reading-preferences/${encodeURIComponent(seriesName)}`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        console.log('üìö Pr√©f√©rences de lecture charg√©es:', data);
        return new Set(data.read_tomes || []);
      } else {
        console.log('‚ÑπÔ∏è Aucune pr√©f√©rence trouv√©e, initialisation vide');
        return new Set();
      }
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement des pr√©f√©rences:', error);
      return new Set();
    }
  };

  // ‚úÖ NOUVELLE FONCTION : Sauvegarder les pr√©f√©rences de lecture en base de donn√©es
  const saveReadingPreferences = async (seriesName, readTomes) => {
    try {
      const token = localStorage.getItem('token');
      const backendUrl = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8001';
      
      const response = await fetch(`${backendUrl}/api/series/reading-preferences`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          series_name: seriesName,
          read_tomes: [...readTomes]
        })
      });
      
      if (response.ok) {
        const data = await response.json();
        console.log('‚úÖ Pr√©f√©rences sauvegard√©es:', data);
        return true;
      } else {
        console.error('‚ùå Erreur lors de la sauvegarde:', response.status);
        return false;
      }
    } catch (error) {
      console.error('‚ùå Erreur lors de la sauvegarde des pr√©f√©rences:', error);
      return false;
    }
  };

  // ‚úÖ NOUVELLE FONCTION : Charger les pr√©f√©rences pour la s√©rie courante
  const loadReadingPreferencesForSeries = async () => {
    if (!enrichedSeries?.name) return;
    
    try {
      const preferences = await loadReadingPreferences(enrichedSeries.name);
      setReadTomes(preferences);
      console.log('üìö Pr√©f√©rences charg√©es pour', enrichedSeries.name, ':', preferences.size, 'tomes');
      
      // ‚úÖ NOUVEAU : Calculer et mettre √† jour le statut de la s√©rie au chargement
      await calculateAndUpdateSeriesStatus(preferences);
      
    } catch (error) {
      console.error('‚ùå Erreur chargement pr√©f√©rences:', error);
      // Fallback : initialiser vide en cas d'erreur
      setReadTomes(new Set());
    }
  };

  // Fonction pour enrichir les donn√©es de s√©rie avec les m√©tadonn√©es de r√©f√©rence
  const enrichSeriesData = (series) => {
    if (!series?.name) return series;
    
    // Rechercher dans la base de donn√©es de r√©f√©rence
    const seriesName = series.name.toLowerCase();
    let referenceData = null;
    
    // Parcourir toutes les cat√©gories de la base de donn√©es de r√©f√©rence
    for (const category of Object.values(EXTENDED_SERIES_DATABASE)) {
      for (const seriesData of Object.values(category)) {
        if (seriesData.name.toLowerCase() === seriesName || 
            seriesData.variations?.some(variation => variation.toLowerCase() === seriesName)) {
          referenceData = seriesData;
          break;
        }
      }
      if (referenceData) break;
    }
    
    // Enrichir avec les donn√©es de r√©f√©rence si trouv√©es
    if (referenceData) {
      return {
        ...series,
        volumes: referenceData.volumes,
        volume_titles: referenceData.volume_titles, // ‚Üê AJOUT: Inclure les vrais noms des tomes
        volume_details: referenceData.volume_details, // ‚Üê AJOUT: D√©tails par tome pour mini-fiches
        description: referenceData.description,
        first_published: referenceData.first_published,
        status: referenceData.status,
        referenceFound: true
      };
    }
    
    return series;
  };

  // ‚úÖ NOUVELLE FONCTION : Calculer et mettre √† jour automatiquement le statut de la s√©rie
  const calculateAndUpdateSeriesStatus = async (newReadTomes) => {
    if (!enrichedSeries?.name || !enrichedSeries?.volumes) {
      console.log('üîÑ Calcul statut ignor√© - s√©rie non valide ou donn√©es manquantes');
      return;
    }

    // ‚úÖ CORRECTION : Permettre le calcul m√™me si la s√©rie n'est pas encore "officiellement" poss√©d√©e
    // L'utilisateur peut marquer des tomes comme lus avant d'ajouter la s√©rie √† sa biblioth√®que
    const totalTomes = enrichedSeries.volumes;
    const readTomesCount = newReadTomes.size;
    
    console.log('üìä Calcul statut s√©rie:', {
      seriesName: enrichedSeries.name,
      totalTomes,
      readTomesCount,
      readTomes: Array.from(newReadTomes),
      isSeriesOwned
    });

    // D√©terminer le nouveau statut selon les r√®gles
    let newStatus = 'to_read'; // Par d√©faut
    
    if (readTomesCount === 0) {
      newStatus = 'to_read'; // Aucun tome lu = √Ä lire
    } else if (readTomesCount === totalTomes) {
      newStatus = 'completed'; // Tous les tomes lus = Termin√©
    } else {
      newStatus = 'reading'; // Quelques tomes lus = En cours
    }

    console.log('üéØ Nouveau statut calcul√©:', newStatus, 'depuis', seriesStatus);

    // ‚úÖ CORRECTION : Seulement tenter la mise √† jour API si la s√©rie est poss√©d√©e
    // Sinon, juste mettre √† jour l'√©tat local pour l'affichage
    if (isSeriesOwned && newStatus !== seriesStatus) {
      console.log('üîÑ Mise √† jour statut s√©rie automatique (s√©rie poss√©d√©e):', seriesStatus, '‚Üí', newStatus);
      
      try {
        // Utiliser la fonction existante pour changer le statut
        await handleQuickStatusChange(newStatus);
        
        // Notification utilisateur pour s√©rie poss√©d√©e
        const statusLabels = {
          'to_read': '√Ä lire',
          'reading': 'En cours',
          'completed': 'Termin√©'
        };
        
        toast.success(`Statut de la s√©rie mis √† jour automatiquement : ${statusLabels[newStatus]}`, {
          icon: 'üéØ',
          duration: 3000
        });
        
      } catch (error) {
        console.error('‚ùå Erreur lors de la mise √† jour automatique du statut:', error);
      }
    } else if (!isSeriesOwned && newStatus !== seriesStatus) {
      console.log('üìù Mise √† jour statut s√©rie local (s√©rie non poss√©d√©e):', seriesStatus, '‚Üí', newStatus);
      
      // Mettre √† jour l'√©tat local pour l'affichage m√™me si s√©rie non poss√©d√©e
      setSeriesStatus(newStatus);
      
      // Notification utilisateur pour s√©rie non poss√©d√©e
      const statusLabels = {
        'to_read': '√Ä lire',
        'reading': 'En cours',
        'completed': 'Termin√©'
      };
      
      toast.success(`Progression mise √† jour : ${statusLabels[newStatus]}`, {
        icon: 'üìà',
        duration: 2000
      });
    } else {
      console.log('‚ÑπÔ∏è Statut s√©rie inchang√©, pas de mise √† jour n√©cessaire');
    }
  };

  // Fonction pour basculer l'√©tat lu/non lu d'un tome avec sauvegarde en base de donn√©es
  const handleTomeReadToggle = async (tomeNumber) => {
    const newReadTomes = new Set(readTomes);
    
    if (newReadTomes.has(tomeNumber)) {
      // D√©cocher le tome
      newReadTomes.delete(tomeNumber);
      setMissingPreviousWarning(null); // Effacer l'avertissement si on d√©coche
    } else {
      // Cocher le tome
      newReadTomes.add(tomeNumber);
      
      // ‚úÖ LOGIQUE SUGGESTION : V√©rifier si des tomes pr√©c√©dents manquent
      if (tomeNumber > 1) {
        const missingPrevious = [];
        for (let i = 1; i < tomeNumber; i++) {
          if (!newReadTomes.has(i)) {
            missingPrevious.push(i);
          }
        }
        
        if (missingPrevious.length > 0) {
          setMissingPreviousWarning({
            currentTome: tomeNumber,
            missingTomes: missingPrevious
          });
        } else {
          setMissingPreviousWarning(null);
        }
      } else {
        setMissingPreviousWarning(null);
      }
    }
    
    // Mettre √† jour l'√©tat local imm√©diatement
    setReadTomes(newReadTomes);
    
    // ‚úÖ PERSISTANCE : Sauvegarder en base de donn√©es
    if (enrichedSeries?.name) {
      const saved = await saveReadingPreferences(enrichedSeries.name, newReadTomes);
      if (saved) {
        console.log('‚úÖ Pr√©f√©rences sauvegard√©es automatiquement');
      } else {
        console.warn('‚ö†Ô∏è √âchec de la sauvegarde, √©tat local maintenu');
        // Note: On garde l'√©tat local m√™me si la sauvegarde √©choue
        // L'utilisateur peut r√©essayer et √ßa sera sauvegard√©
      }
    }

    // ‚úÖ NOUVEAU : Calculer et mettre √† jour automatiquement le statut de la s√©rie
    await calculateAndUpdateSeriesStatus(newReadTomes);
  };

  // Fonction pour cocher automatiquement tous les tomes pr√©c√©dents avec sauvegarde
  const handleCheckPreviousTomes = async () => {
    if (!missingPreviousWarning) return;
    
    const newReadTomes = new Set(readTomes);
    // Ajouter tous les tomes manquants
    missingPreviousWarning.missingTomes.forEach(tomeNumber => {
      newReadTomes.add(tomeNumber);
    });
    
    // Mettre √† jour l'√©tat local
    setReadTomes(newReadTomes);
    
    // ‚úÖ PERSISTANCE : Sauvegarder en base de donn√©es
    if (enrichedSeries?.name) {
      const saved = await saveReadingPreferences(enrichedSeries.name, newReadTomes);
      if (saved) {
        console.log('‚úÖ Pr√©f√©rences sauvegard√©es apr√®s cochage automatique');
      } else {
        console.warn('‚ö†Ô∏è √âchec de la sauvegarde, √©tat local maintenu');
      }
    }
    
    // Effacer l'avertissement
    setMissingPreviousWarning(null);

    // ‚úÖ NOUVEAU : Calculer et mettre √† jour automatiquement le statut de la s√©rie
    await calculateAndUpdateSeriesStatus(newReadTomes);
  };

  // Enrichir les donn√©es de s√©rie au chargement
  const enrichedSeries = enrichSeriesData(series);

  // Options de statut pour les boutons rapides
  const statusOptions = [
    { value: 'to_read', label: '√Ä lire', color: 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-300', emoji: '' },
    { value: 'reading', label: 'En cours', color: 'bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-300', emoji: '' },
    { value: 'completed', label: 'Termin√©', color: 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300', emoji: '' },
  ];

  // Fonction pour changer rapidement le statut de la s√©rie
  const handleQuickStatusChange = async (newStatus) => {
    console.log('üéØ D√âBUT handleQuickStatusChange:', { newStatus, isSeriesOwned, series });
    
    if (!isSeriesOwned) {
      console.log('‚ùå S√©rie non poss√©d√©e, affichage erreur');
      toast.error('Vous devez d\'abord ajouter cette s√©rie √† votre biblioth√®que');
      return;
    }

    try {
      const token = localStorage.getItem('token');
      const backendUrl = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8001';
      
      console.log('üîë Token trouv√©:', !!token);
      console.log('üîÑ Changement statut s√©rie:', series.name, 'vers', newStatus);
      
      // Rechercher le livre s√©rie dans la biblioth√®que
      const response = await fetch(`${backendUrl}/api/books/all?saga=${encodeURIComponent(series.name)}`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      console.log('üì° R√©ponse recherche s√©rie:', { status: response.status, ok: response.ok });
      
      if (response.ok) {
        const data = await response.json();
        console.log('üìö Donn√©es re√ßues:', data);
        
        // CORRECTION RCA: M√™me logique case-insensitive pour chercher le livre s√©rie
        const seriesBook = data.items?.find(book => 
          book.saga?.toLowerCase().includes(series.name.toLowerCase()) && 
          (book.is_series === true || book.title?.toLowerCase().includes('collection'))
        );
        
        if (seriesBook) {
          console.log('üìñ Livre s√©rie trouv√©:', seriesBook);
          // Mettre √† jour le statut du livre s√©rie
          const updateResponse = await fetch(`${backendUrl}/api/books/${seriesBook.id}`, {
            method: 'PUT',
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ status: newStatus })
          });
          
          console.log('üîÑ R√©ponse mise √† jour:', { status: updateResponse.status, ok: updateResponse.ok });
          
          if (updateResponse.ok) {
            const updatedBook = await updateResponse.json();
            console.log('‚úÖ Livre mis √† jour:', updatedBook);
            setSeriesStatus(newStatus);
            toast.success(`Statut de la s√©rie "${series.name}" chang√© vers "${statusOptions.find(s => s.value === newStatus)?.label}"`);
            
            // Actualiser la biblioth√®que
            if (onUpdate) {
              console.log('üîÑ Actualisation biblioth√®que');
              onUpdate();
            }
          } else {
            const errorData = await updateResponse.json();
            console.error('‚ùå Erreur mise √† jour:', errorData);
            toast.error('Erreur lors de la mise √† jour du statut');
          }
        } else {
          console.error('‚ùå Livre s√©rie non trouv√© dans les r√©sultats');
          console.log('üìã Livres disponibles:', data.items?.map(b => ({ title: b.title, saga: b.saga, is_series: b.is_series })));
          toast.error('Livre s√©rie non trouv√© dans la biblioth√®que');
        }
      } else {
        const errorData = await response.json();
        console.error('‚ùå Erreur recherche s√©rie:', errorData);
        toast.error('Erreur lors de la recherche de la s√©rie');
      }
    } catch (error) {
      console.error('‚ùå Erreur g√©n√©rale changement statut:', error);
      toast.error('Erreur lors du changement de statut');
    }
  };

  // Fonction pour v√©rifier si la s√©rie est d√©j√† dans la biblioth√®que
  const checkIfSeriesOwned = async () => {
    if (!series?.name) {
      console.log('‚ö†Ô∏è Pas de nom de s√©rie fourni');
      return;
    }
    
    try {
      const token = localStorage.getItem('token');
      const backendUrl = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8001';
      
      console.log('üîç V√©rification s√©rie poss√©d√©e:', series.name);
      console.log('üîë Token disponible:', !!token);
      console.log('üåê Backend URL:', backendUrl);
      
      // Rechercher les livres de cette saga
      const response = await fetch(`${backendUrl}/api/books/all?saga=${encodeURIComponent(series.name)}`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      console.log('üì° R√©ponse v√©rification:', { 
        status: response.status, 
        ok: response.ok,
        statusText: response.statusText 
      });
      
      if (response.ok) {
        const data = await response.json();
        console.log('üìö Livres trouv√©s pour saga:', data);
        
        // CORRECTION RCA: Utiliser case-insensitive substring match pour compatibilit√© avec regex backend
        const hasSeriesBook = data.items && data.items.some(book => 
          book.saga?.toLowerCase().includes(series.name.toLowerCase()) && 
          (book.is_series === true || book.title?.toLowerCase().includes('collection'))
        );
        
        console.log('üìñ S√©rie d√©j√† poss√©d√©e:', hasSeriesBook);
        setIsSeriesOwned(hasSeriesBook);
        
        // R√©cup√©rer le statut de la s√©rie si elle existe
        if (hasSeriesBook) {
          // CORRECTION RCA: M√™me logique case-insensitive pour r√©cup√©rer le statut
          const seriesBook = data.items.find(book => 
            book.saga?.toLowerCase().includes(series.name.toLowerCase()) && 
            (book.is_series === true || book.title?.toLowerCase().includes('collection'))
          );
          if (seriesBook) {
            setSeriesStatus(seriesBook.status || 'to_read');
            console.log('üìä Statut s√©rie r√©cup√©r√©:', seriesBook.status);
          }
        }
        
        console.log('‚úÖ S√©rie d√©j√† poss√©d√©e:', hasSeriesBook);
      } else {
        const errorData = await response.json().catch(() => ({ detail: 'Erreur inconnue' }));
        console.error('‚ùå Erreur API v√©rification s√©rie:', {
          status: response.status,
          statusText: response.statusText,
          error: errorData
        });
        // Ne pas bloquer l'interface si l'API √©choue
        setIsSeriesOwned(false);
      }
    } catch (error) {
      console.error('‚ùå Erreur lors de la v√©rification de la s√©rie:', error);
      // Ne pas bloquer l'interface si la v√©rification √©choue
      setIsSeriesOwned(false);
    }
  };

  useEffect(() => {
    if (isOpen && series) {
      loadSeriesBooks();
      checkIfSeriesOwned();
      // ‚úÖ PERSISTANCE : Charger les pr√©f√©rences depuis la base de donn√©es au lieu de r√©initialiser
      loadReadingPreferencesForSeries();
      setMissingPreviousWarning(null); // ‚Üê AJOUT: R√©initialiser l'avertissement √† chaque ouverture
    }
  }, [isOpen, series]);

  const loadSeriesBooks = async () => {
    if (!series?.name) return;
    
    try {
      setLoading(true);
      const booksData = await bookService.getBooksBySaga(series.name);
      setBooks(booksData.sort((a, b) => (a.volume_number || 0) - (b.volume_number || 0)));
    } catch (error) {
      console.error('Erreur lors du chargement des livres de la s√©rie:', error);
      toast.error('Erreur lors du chargement des livres');
    } finally {
      setLoading(false);
    }
  };

  const handleTomeToggle = async (book, isRead) => {
    try {
      await bookService.toggleTomeStatus(series.name, book.volume_number, isRead);
      await loadSeriesBooks();
      if (onUpdate) onUpdate();
      toast.success(`Tome ${book.volume_number} marqu√© comme ${isRead ? 'lu' : 'non lu'}`);
    } catch (error) {
      console.error('Erreur lors de la mise √† jour du tome:', error);
      toast.error('Erreur lors de la mise √† jour');
    }
  };

  const handleAutoComplete = async () => {
    try {
      setAutoCompleting(true);
      const maxVolume = Math.max(...books.map(b => b.volume_number || 0));
      const targetVolume = Math.max(maxVolume + 10, 20);

      const result = await bookService.autoCompleteSaga(series.name, targetVolume);
      await loadSeriesBooks();
      if (onUpdate) onUpdate();
      toast.success(`${result.created_books?.length || 0} nouveaux tomes ajout√©s !`);
    } catch (error) {
      console.error('Erreur lors de l\'auto-compl√©tion:', error);
      toast.error('Erreur lors de l\'auto-compl√©tion');
    } finally {
      setAutoCompleting(false);
    }
  };

  const handleAnalyzeMissing = async () => {
    try {
      setAnalyzing(true);
      const analysis = await bookService.analyzeMissingVolumes(series.name);
      setMissingAnalysis(analysis);
      
      if (analysis.missing_volumes.length > 0) {
        toast.success(`${analysis.missing_volumes.length} tome(s) manquant(s) d√©tect√©(s)`);
      } else {
        toast.success('Aucun tome manquant d√©tect√©');
      }
    } catch (error) {
      console.error('Erreur lors de l\'analyse:', error);
      toast.error('Erreur lors de l\'analyse');
    } finally {
      setAnalyzing(false);
    }
  };

  const getStatusBadge = (status) => {
    switch (status) {
      case 'completed':
        return 'bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-300';
      case 'reading':
        return 'bg-blue-100 text-blue-800 dark:bg-blue-900/20 dark:text-blue-300';
      default:
        return 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'completed': return 'Lu';
      case 'reading': return 'En cours';
      default: return 'Non lu';
    }
  };

  const getCategoryEmoji = (category) => {
    switch (category) {
      case 'bd': return 'üé®';
      case 'manga': return 'üáØüáµ';
      case 'roman': return 'üìö';
      default: return 'üìñ';
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="modal-content-wide shadow-2xl overflow-hidden">>
        
        {/* Header */}
        <div className="border-b border-gray-200 dark:border-gray-700 p-6">
          <div className="flex items-start justify-between">
            <div className="flex items-center space-x-4">
              {/* Image de couverture ou ic√¥ne de s√©rie */}
              <div className="w-16 h-20 rounded-lg flex items-center justify-center shadow-md overflow-hidden">
                {series.cover_url ? (
                  <img 
                    src={series.cover_url} 
                    alt={`Couverture de ${series.name}`}
                    className="w-full h-full object-cover"
                    onError={(e) => {
                      // Fallback vers le d√©grad√© si l'image ne charge pas
                      e.target.style.display = 'none';
                      e.target.nextSibling.style.display = 'flex';
                    }}
                  />
                ) : null}
                <div 
                  className={`w-full h-full bg-gradient-to-br from-purple-500 to-blue-600 rounded-lg flex items-center justify-center text-white text-2xl ${series.cover_url ? 'hidden' : 'flex'}`}
                >
                  {getCategoryEmoji(series?.category)}
                </div>
              </div>
              
              <div>
                <h2 className="text-2xl font-bold text-gray-900 dark:text-white mb-1">
                  {series?.name}
                </h2>
                <p className="text-gray-600 dark:text-gray-400 mb-2">
                  par {series?.author}
                </p>
                <div className="flex items-center space-x-4 text-sm">
                  <span className={`px-2 py-1 rounded-full text-xs font-medium ${getStatusBadge(series?.status)}`}>
                    {getStatusLabel(series?.status)}
                  </span>
                  <span className="text-gray-500 dark:text-gray-400">
                    üìö {books.length} tome(s)
                  </span>
                  <span className="text-gray-500 dark:text-gray-400">
                    üèÜ {series?.completion_percentage || 0}% compl√©t√©
                  </span>
                </div>
              </div>
            </div>
            
            <div className="flex items-center space-x-2">
              {/* Bouton Ajouter fonctionnel (m√™me style que BookDetailModal) */}
              {!isSeriesOwned && onAddSeries && (
                <button
                  onClick={async () => {
                    try {
                      console.log('üü¢ Clic sur ajouter s√©rie:', series);
                      await onAddSeries(series);
                      // CORRECTION: Attendre un peu puis re-v√©rifier si la s√©rie est poss√©d√©e
                      setTimeout(() => {
                        checkIfSeriesOwned();
                      }, 1000);
                    } catch (error) {
                      console.error('‚ùå Erreur lors de l\'ajout de la s√©rie:', error);
                    }
                  }}
                  className="px-4 py-2 text-sm font-medium text-white bg-green-600 hover:bg-green-700 rounded-md transition-colors flex items-center space-x-2"
                >
                  <span>+</span>
                  <span>Ajouter √† ma biblioth√®que</span>
                </button>
              )}
              
              <button
                onClick={onClose}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 text-xl"
              >
                ‚úï
              </button>
            </div>
          </div>
        </div>

        {/* Section R√©sum√© de la s√©rie */}
        {enrichedSeries?.description && (
          <div className="border-b border-gray-200 dark:border-gray-700 px-6 py-4">
            <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-3 flex items-center">
              <BookOpenIcon className="w-5 h-5 mr-2 text-purple-600 dark:text-purple-400" />
              R√©sum√© de la s√©rie
            </h3>
            <div className="prose prose-gray dark:prose-invert max-w-none">
              <p className="text-gray-700 dark:text-gray-300 text-sm leading-relaxed">
                {enrichedSeries.description}
              </p>
            </div>
          </div>
        )}

        {/* Boutons rapides de changement de statut - M√äME EMPLACEMENT QUE DANS BookDetailModal */}
        <div className="px-6 py-4 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center mb-2">
            <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300">Changer le statut rapidement :</h3>
            {/* Indicateur de debug */}
            <span className="ml-2 text-xs text-gray-500">
              (S√©rie poss√©d√©e: {isSeriesOwned ? '‚úÖ' : '‚ùå'})
            </span>
          </div>
          <div className="flex rounded-lg overflow-hidden border border-gray-200 dark:border-gray-600 w-fit">
            {statusOptions.map((option) => (
              <button
                key={option.value}
                onClick={() => {
                  console.log('üñ±Ô∏è CLIC BOUTON STATUT:', {
                    option: option.value,
                    isSeriesOwned,
                    seriesName: series?.name
                  });
                  handleQuickStatusChange(option.value);
                }}
                className={`px-4 py-2 text-sm font-medium transition-all flex items-center space-x-2 ${
                  seriesStatus === option.value
                    ? 'bg-gray-900 dark:bg-white text-white dark:text-gray-900 shadow-md'
                    : 'bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600'
                }`}
                title={`Marquer comme ${option.label}`}
                disabled={!isSeriesOwned}
              >
                <span className="text-base">{option.emoji}</span>
                <span>{option.label}</span>
              </button>
            ))}
          </div>
          {!isSeriesOwned && (
            <p className="text-xs text-gray-500 mt-2">
              Ajoutez d'abord cette s√©rie √† votre biblioth√®que pour changer son statut
            </p>
          )}
        </div>

        {/* Actions Bar */}
        <div className="border-b border-gray-200 dark:border-gray-700 px-6 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-3">
              {selectedTomes.size > 0 && (
                <div className="flex items-center space-x-2">
                  <span className="text-sm text-gray-600 dark:text-gray-400">
                    {selectedTomes.size} s√©lectionn√©(s)
                  </span>
                  <button
                    onClick={() => setSelectedTomes(new Set())}
                    className="px-3 py-1 bg-red-600 text-white rounded text-sm hover:bg-red-700"
                  >
                    D√©s√©lectionner
                  </button>
                </div>
              )}
            </div>
            
            <div className="flex items-center space-x-2">
              <button
                onClick={handleAnalyzeMissing}
                disabled={analyzing}
                className="p-2 text-orange-600 hover:bg-orange-50 dark:hover:bg-orange-900/20 rounded-full transition-colors"
                title="Analyser les tomes manquants"
              >
                {analyzing ? (
                  <div className="w-5 h-5 border-2 border-orange-600 border-t-transparent rounded-full animate-spin" />
                ) : (
                  <MagnifyingGlassIcon className="w-5 h-5" />
                )}
              </button>
              
              <button
                onClick={handleAutoComplete}
                disabled={autoCompleting}
                className="p-2 text-blue-600 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-full transition-colors"
                title="Auto-compl√©ter la s√©rie"
              >
                {autoCompleting ? (
                  <div className="w-5 h-5 border-2 border-blue-600 border-t-transparent rounded-full animate-spin" />
                ) : (
                  <SparklesIcon className="w-5 h-5" />
                )}
              </button>
            </div>
          </div>
        </div>

        {/* Missing Volumes Analysis */}
        {missingAnalysis && missingAnalysis.missing_volumes.length > 0 && (
          <div className="bg-orange-50 dark:bg-orange-900/20 border-b border-orange-200 dark:border-orange-800 px-6 py-3">
            <div className="flex items-center space-x-2 text-orange-800 dark:text-orange-300">
              <ExclamationTriangleIcon className="w-4 h-4" />
              <span className="text-sm font-medium">
                {missingAnalysis.missing_volumes.length} tome(s) manquant(s) : 
                {missingAnalysis.missing_volumes.slice(0, 10).join(', ')}
                {missingAnalysis.missing_volumes.length > 10 && '...'}
              </span>
            </div>
          </div>
        )}

        {/* Liste des tomes avec mini-fiches dropdown */}
        <div className="border-b border-gray-200 dark:border-gray-700 px-6 py-4">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-3">Liste des tomes</h3>
          
          {enrichedSeries?.volumes && enrichedSeries.volumes > 0 ? (
            <div className="space-y-1">
              {Array.from({ length: enrichedSeries.volumes }, (_, index) => {
                const tomeNumber = index + 1;
                // Utiliser le titre sp√©cifique s'il existe, sinon titre g√©n√©rique
                const tomeTitle = enrichedSeries.volume_titles?.[tomeNumber] || `${enrichedSeries.name} - Tome ${tomeNumber}`;
                const isRead = readTomes.has(tomeNumber);
                
                return (
                  <TomeDropdown
                    key={tomeNumber}
                    tomeNumber={tomeNumber}
                    tomeTitle={tomeTitle}
                    seriesData={enrichedSeries}
                    isRead={isRead}
                    onToggleRead={handleTomeReadToggle}
                  />
                );
              })}
            </div>
          ) : (
            <p className="text-sm text-gray-500 dark:text-gray-400 italic">
              Informations sur les tomes non disponibles pour cette s√©rie
            </p>
          )}
        </div>

        {/* Modal de confirmation pour cocher les tomes pr√©c√©dents */}
        {missingPreviousWarning && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4 shadow-xl">
              <div className="flex items-center space-x-3 mb-4">
                <div className="p-2 bg-blue-100 dark:bg-blue-900/20 rounded-full">
                  <ExclamationTriangleIcon className="w-6 h-6 text-blue-600 dark:text-blue-400" />
                </div>
                <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                  Suggestion de lecture
                </h3>
              </div>
              
              <div className="mb-6">
                <p className="text-gray-700 dark:text-gray-300 mb-3">
                  Vous avez marqu√© comme lu le <strong>tome {missingPreviousWarning.currentTome}</strong>.
                </p>
                <p className="text-gray-600 dark:text-gray-400 text-sm">
                  Souhaitez-vous √©galement marquer comme lus les tomes pr√©c√©dents ?
                </p>
                <div className="mt-2 text-sm text-gray-500 dark:text-gray-400">
                  <strong>Tomes concern√©s :</strong> {missingPreviousWarning.missingTomes.join(', ')}
                </div>
              </div>
              
              <div className="flex space-x-3">
                <button
                  onClick={handleCheckPreviousTomes}
                  className="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors duration-200 text-sm font-medium"
                >
                  Oui, cocher les pr√©c√©dents
                </button>
                <button
                  onClick={() => setMissingPreviousWarning(null)}
                  className="flex-1 bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-700 dark:text-gray-300 px-4 py-2 rounded-lg transition-colors duration-200 text-sm font-medium"
                >
                  Non, juste ce tome
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Books List (Section d√©taill√©e existante) - SUPPRIM√âE SUR DEMANDE UTILISATEUR */}

      </div>
    </div>
  );
};

export default SeriesDetailModal;